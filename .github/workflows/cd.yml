name: CD - Build & Deploy Docker Images

on:
  # Manual trigger - use dry_run to test without pushing
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional additional tag (latest is always pushed)'
        required: false
        type: string
      no_cache:
        description: 'Disable Docker layer cache (force full rebuild)'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Build and test only - do NOT push to registry'
        required: false
        type: boolean
        default: false

  # Auto-validate CD changes on PRs (dry-run mode, no push)
  # This catches CD breakage BEFORE it merges to main
  pull_request:
    paths:
      - 'Dockerfile'
      - 'docker-compose*.yml'
      - 'docker/**'
      - '.github/workflows/cd.yml'

  # On version tags only (semver pattern)
  # Use: git tag -a v0.1.0 -m "Release message" && git push --tags
  # Note: release.sh creates the GitHub release, so we don't trigger on release events
  push:
    tags:
      - 'v*'

env:
  REGISTRY: ghcr.io
  USERNAME: adamflagg

# Prevent multiple CD runs for the same ref
concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Detect what changed to optimize builds
  detect-changes:
    name: Detect Changed Files
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      docker: ${{ steps.filter.outputs.docker }}
      initial_commit: ${{ steps.get-base-sha.outputs.initial_commit }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Get base SHA for comparison
      id: get-base-sha
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        echo "Checking for last successful CD run..."
        echo "Current commit SHA: ${{ github.sha }}"

        LAST_SUCCESS_SHA=$(gh run list \
          --workflow cd.yml \
          --branch main \
          --status success \
          --limit 5 \
          --json headSha \
          --jq '.[] | select(.headSha != "${{ github.sha }}") | .headSha' | head -1 || echo "")

        if [ -n "$LAST_SUCCESS_SHA" ]; then
          echo "Found previous successful run: $LAST_SUCCESS_SHA"
          BASE_SHA=$LAST_SUCCESS_SHA
          echo "initial_commit=false" >> $GITHUB_OUTPUT
        elif git rev-parse HEAD~1 >/dev/null 2>&1; then
          echo "No previous successful runs found, falling back to HEAD~1"
          BASE_SHA=$(git rev-parse HEAD~1)
          echo "Using previous commit: $BASE_SHA"
          echo "initial_commit=false" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è Initial commit detected (no parent) - building all images"
          # For initial commit, use HEAD as base (no changes detected by paths-filter)
          # but set flag to force all builds
          BASE_SHA=${{ github.sha }}
          echo "initial_commit=true" >> $GITHUB_OUTPUT
        fi

        echo "base_sha=$BASE_SHA" >> $GITHUB_OUTPUT
        echo "Comparing changes from $BASE_SHA to ${{ github.sha }}"

        if [ "$BASE_SHA" != "${{ github.sha }}" ]; then
          echo "=== Change Detection Summary ==="
          echo "Files changed:"
          git diff --name-only $BASE_SHA HEAD 2>/dev/null | head -20
          echo "Total files changed: $(git diff --name-only $BASE_SHA HEAD 2>/dev/null | wc -l)"
        else
          echo "=== Initial commit - all files are new ==="
        fi

    - name: Check for file changes
      uses: dorny/paths-filter@v3
      id: filter
      with:
        base: ${{ steps.get-base-sha.outputs.base_sha }}
        filters: |
          api:
            - 'api/**'
            - 'bunking/**'
            - 'campminder/**'
            - 'pocketbase/**'
            - 'frontend/**'
            - 'config/*.json'
            - 'pyproject.toml'
            - 'uv.lock'
            - 'Dockerfile'
            - 'docker/supervisord.conf'
            - 'docker/combined-entrypoint.sh'
            - 'docker/Caddyfile'
          docker:
            - 'Dockerfile'
            - 'docker-compose*.yml'
            - '.dockerignore'

  # Verify CI and docs checks passed for tag pushes
  # This reuses results from the branch push - no duplicate runs
  verify-ci:
    name: Verify CI Passed
    needs: detect-changes
    if: github.event_name != 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      checks: read
    steps:
    - name: Check CI and docs status for this commit
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # For PRs, github.sha is the merge commit (virtual), not the PR head commit
        # CI runs on the PR head commit, so we need to check that instead
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          CHECK_SHA="${{ github.event.pull_request.head.sha }}"
          echo "PR event: checking PR head commit $CHECK_SHA"
        else
          CHECK_SHA="${{ github.sha }}"
          echo "Checking check runs for $CHECK_SHA..."
        fi

        # Helper to get check status by name
        get_check_status() {
          local check_name="$1"
          gh api repos/${{ github.repository }}/commits/${CHECK_SHA}/check-runs \
            --jq ".check_runs[] | select(.name == \"$check_name\") | {status: .status, conclusion: .conclusion}"
        }

        # For tag pushes, check if CI already passed (commit was tested on branch)
        # This saves ~1-5 minutes when tagging a commit that already passed CI
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          EXISTING_SUCCESS=$(gh api repos/${{ github.repository }}/commits/${CHECK_SHA}/check-runs \
            --jq '.check_runs[] | select(.name == "CI Summary" and .conclusion == "success") | .id' | head -1 || echo "")
          if [ -n "$EXISTING_SUCCESS" ]; then
            echo "‚úÖ CI Summary already passed for this commit - skipping wait"
            exit 0
          fi
        fi

        # Wait for CI Summary (required)
        echo "=== Verifying CI Summary ==="
        for i in {1..20}; do
          CI_RESULTS=$(get_check_status "CI Summary")
          SUCCESS_COUNT=$(echo "$CI_RESULTS" | jq -s '[.[] | select(.status == "completed" and .conclusion == "success")] | length')
          FAILED_COUNT=$(echo "$CI_RESULTS" | jq -s '[.[] | select(.status == "completed" and .conclusion != "success")] | length')
          PENDING_COUNT=$(echo "$CI_RESULTS" | jq -s '[.[] | select(.status != "completed")] | length')
          TOTAL_COUNT=$(echo "$CI_RESULTS" | jq -s 'length')

          echo "  Attempt $i/20: CI runs: $TOTAL_COUNT (Success: $SUCCESS_COUNT, Failed: $FAILED_COUNT, Pending: $PENDING_COUNT)"

          if [ "$TOTAL_COUNT" -eq 0 ]; then
            echo "  No CI Summary checks found yet, waiting..."
            sleep 30
            continue
          fi

          if [ "$SUCCESS_COUNT" -gt 0 ]; then
            echo "‚úÖ CI Summary passed"
            break
          fi

          if [ "$PENDING_COUNT" -eq 0 ] && [ "$SUCCESS_COUNT" -eq 0 ]; then
            echo "‚ùå CI Summary failed"
            exit 1
          fi

          sleep 30
        done

        if [ "$SUCCESS_COUNT" -eq 0 ]; then
          echo "‚ùå CI timed out after 10 minutes"
          exit 1
        fi

        # Check docs if Documentation Linting check exists (means docs were changed)
        echo ""
        echo "=== Checking Documentation Linting (if applicable) ==="
        DOCS_RESULTS=$(get_check_status "Documentation Linting")
        DOCS_COUNT=$(echo "$DOCS_RESULTS" | jq -s 'length')

        if [ "$DOCS_COUNT" -eq 0 ]; then
          echo "‚ÑπÔ∏è  No docs check found (no doc changes in this commit)"
        else
          DOCS_SUCCESS=$(echo "$DOCS_RESULTS" | jq -s '[.[] | select(.status == "completed" and .conclusion == "success")] | length')
          DOCS_FAILED=$(echo "$DOCS_RESULTS" | jq -s '[.[] | select(.status == "completed" and .conclusion != "success")] | length')

          if [ "$DOCS_SUCCESS" -gt 0 ]; then
            echo "‚úÖ Documentation Linting passed"
          elif [ "$DOCS_FAILED" -gt 0 ]; then
            echo "‚ùå Documentation Linting failed"
            exit 1
          else
            echo "‚è≥ Documentation Linting still running, waiting..."
            for j in {1..10}; do
              sleep 15
              DOCS_RESULTS=$(get_check_status "Documentation Linting")
              DOCS_SUCCESS=$(echo "$DOCS_RESULTS" | jq -s '[.[] | select(.status == "completed" and .conclusion == "success")] | length')
              if [ "$DOCS_SUCCESS" -gt 0 ]; then
                echo "‚úÖ Documentation Linting passed"
                break
              fi
            done
            if [ "$DOCS_SUCCESS" -eq 0 ]; then
              echo "‚ùå Documentation Linting did not complete successfully"
              exit 1
            fi
          fi
        fi

        echo ""
        echo "‚úÖ All required checks passed for this commit"

  # Smoke test for manual triggers
  smoke-test:
    name: Smoke Test (Manual)
    needs: detect-changes
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Install git-crypt (cached)
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: git-crypt
        version: git-crypt-v1

    - name: Unlock git-crypt
      env:
        GIT_CRYPT_KEY: ${{ secrets.GIT_CRYPT_KEY }}
      run: |
        if [ -n "$GIT_CRYPT_KEY" ]; then
          echo "$GIT_CRYPT_KEY" | base64 -d > /tmp/git-crypt-key
          git-crypt unlock /tmp/git-crypt-key
          rm /tmp/git-crypt-key
          echo "‚úÖ git-crypt unlocked"
        else
          echo "‚ö†Ô∏è GIT_CRYPT_KEY not set"
        fi

    - name: Setup Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.14'

    - name: Install uv
      uses: astral-sh/setup-uv@v5

    - name: Setup Node.js
      uses: actions/setup-node@v6
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Verify Python imports
      run: |
        uv sync --frozen -q
        uv run python -c "import bunking; import api; print('‚úÖ Python imports OK')"

    - name: Verify TypeScript compiles
      working-directory: ./frontend
      run: |
        npm ci
        npm run type-check
        echo "‚úÖ TypeScript OK"

  # Build, test, then push Docker image (single combined container)
  # Following Docker's "test before push" pattern:
  # https://docs.docker.com/build/ci/github-actions/test-before-push/
  build-test-push:
    name: Build, Test & Push
    needs: [detect-changes, verify-ci, smoke-test]
    if: |
      always() &&
      (needs.verify-ci.result == 'success' || needs.verify-ci.result == 'skipped') &&
      (needs.smoke-test.result == 'success' || needs.smoke-test.result == 'skipped') &&
      !(needs.verify-ci.result == 'failure' || needs.smoke-test.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write

    strategy:
      matrix:
        include:
          - image: kindred
            dockerfile: Dockerfile
            context: .
            changed: ${{ needs.detect-changes.outputs.api }}

    steps:
    - name: Check if build needed
      id: check
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # For tag pushes, check if image was already pushed locally by release.sh
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          TAG_NAME=${GITHUB_REF#refs/tags/}
          DOCKER_TAG=${TAG_NAME#v}
          echo "Checking if image ${{ matrix.image }}:${DOCKER_TAG} already exists..."

          # Query GitHub Packages API for existing version
          # Note: gh api returns 404 JSON to stdout (not stderr) when package doesn't exist,
          # so we must check exit code explicitly
          if gh api "/users/${{ env.USERNAME }}/packages/container/${{ matrix.image }}/versions" \
               --jq ".[] | select(.metadata.container.tags[] == \"${DOCKER_TAG}\") | .id" \
               > /tmp/existing_id 2>/dev/null; then
            EXISTING=$(head -1 /tmp/existing_id)
          else
            EXISTING=""
          fi

          if [ -n "$EXISTING" ]; then
            echo "build=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Image ${{ matrix.image }}:${DOCKER_TAG} already exists (pushed by local release)"
            echo "   Skipping redundant build"
            exit 0
          else
            echo "Image not found, will build..."
          fi
        fi

        # Standard change detection for non-tag pushes or when image doesn't exist
        if [ "${{ matrix.changed }}" == "true" ] || \
           [ "${{ github.event_name }}" == "workflow_dispatch" ] || \
           [[ "${{ github.ref }}" == refs/tags/* ]] || \
           [ "${{ needs.detect-changes.outputs.docker }}" == "true" ] || \
           [ "${{ needs.detect-changes.outputs.initial_commit }}" == "true" ]; then
          echo "build=true" >> $GITHUB_OUTPUT
        else
          echo "build=false" >> $GITHUB_OUTPUT
          echo "Skipping ${{ matrix.image }} - no changes detected"
        fi

    - name: Checkout code
      if: steps.check.outputs.build == 'true'
      uses: actions/checkout@v6

    - name: Install git-crypt (cached)
      if: steps.check.outputs.build == 'true'
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: git-crypt
        version: git-crypt-v1

    - name: Unlock git-crypt for branding assets
      if: steps.check.outputs.build == 'true' && env.GIT_CRYPT_KEY != ''
      env:
        GIT_CRYPT_KEY: ${{ secrets.GIT_CRYPT_KEY }}
      run: |
        echo "$GIT_CRYPT_KEY" | base64 -d > /tmp/git-crypt-key
        git-crypt unlock /tmp/git-crypt-key
        rm /tmp/git-crypt-key
        echo "‚úÖ git-crypt unlocked - branding assets available"

    - name: Prepare local assets for Docker build
      if: steps.check.outputs.build == 'true'
      run: |
        # Ensure local/ directory exists for Docker COPY (even if empty)
        mkdir -p local/assets
        if [ -f local/assets/camp-tawonga-logo.png ]; then
          echo "‚úÖ Local assets found and decrypted"
          ls -la local/assets/
        else
          echo "‚ÑπÔ∏è  No local assets (git-crypt not unlocked or files not committed)"
          echo "   Using default branding"
        fi

    - name: Set up Docker Buildx
      if: steps.check.outputs.build == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      if: steps.check.outputs.build == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Determine tags
      if: steps.check.outputs.build == 'true'
      id: tags
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.USERNAME }}/${{ matrix.image }}"
        TAGS="${IMAGE}:latest"
        if [ -n "${{ github.event.inputs.tag }}" ]; then
          TAGS="${TAGS},${IMAGE}:${{ github.event.inputs.tag }}"
        fi
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          # Strip 'refs/tags/' prefix, then strip 'v' prefix for Docker tag
          # Git tags remain v0.7.0, Docker tags become 0.7.0, 0.7, latest
          TAG_NAME=${GITHUB_REF#refs/tags/}
          DOCKER_TAG=${TAG_NAME#v}
          TAGS="${TAGS},${IMAGE}:${DOCKER_TAG}"

          # Add minor version tag (e.g., 1.0 from 1.0.0)
          MINOR_TAG=$(echo "$DOCKER_TAG" | cut -d. -f1-2)
          if [[ "$MINOR_TAG" != "$DOCKER_TAG" ]]; then
            TAGS="${TAGS},${IMAGE}:${MINOR_TAG}"
          fi
        fi
        echo "tags=$TAGS" >> $GITHUB_OUTPUT
        echo "Using tags: $TAGS"

    - name: Get version and build date
      if: steps.check.outputs.build == 'true'
      id: version
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION="dev"
        fi
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
        echo "Build Date: $BUILD_DATE"

    - name: Build Docker image (local only)
      if: steps.check.outputs.build == 'true'
      id: build
      uses: docker/build-push-action@v6
      with:
        context: ${{ matrix.context }}
        file: ${{ matrix.dockerfile }}
        load: true
        tags: ${{ env.REGISTRY }}/${{ env.USERNAME }}/${{ matrix.image }}:test
        cache-from: ${{ github.event.inputs.no_cache == 'true' && '' || 'type=gha' }}
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        no-cache: ${{ github.event.inputs.no_cache == 'true' }}
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          BUILD_DATE=${{ steps.version.outputs.build_date }}

    # === Integration Tests (run before push) ===
    - name: Create CI environment file
      if: steps.check.outputs.build == 'true'
      run: |
        CI_DIR="/tmp/kindred-ci-${{ github.run_id }}"
        cat > .env.ci << 'EOF'
        COMPOSE_PROJECT_NAME=kindred-ci-${{ github.run_id }}
        IMAGE_TAG=test
        POCKETBASE_ADMIN_EMAIL=ci@test.local
        POCKETBASE_ADMIN_PASSWORD=ci-test-password
        AUTH_MODE=bypass
        CI=true
        GITHUB_ACTIONS=true
        # Optional vars (empty to suppress warnings)
        CAMPMINDER_API_KEY=
        CAMPMINDER_PRIMARY_KEY=
        CAMPMINDER_CLIENT_ID=
        CAMPMINDER_SEASON_ID=
        SUB_BUNKING=
        DOMAIN_NAME=
        EOF
        # APPDATA_DIR needs shell expansion, add separately
        echo "APPDATA_DIR=${CI_DIR}" >> .env.ci
        # Remove leading whitespace from heredoc
        sed -i 's/^[[:space:]]*//' .env.ci
        mkdir -p ${CI_DIR}/bunking/pocketbase
        sudo chown -R 1000:1000 ${CI_DIR}/bunking/pocketbase

    - name: Start test stack
      if: steps.check.outputs.build == 'true'
      run: |
        # Use CI override to avoid external network requirement
        # --wait uses Docker's native healthcheck polling (configured in docker-compose.yml)
        # --wait-timeout 150 matches our previous 30 attempts √ó 5s = 150s max
        if docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml up -d --wait --wait-timeout 150; then
          echo "‚úÖ Service is healthy!"
        else
          echo "‚ùå Service failed to become healthy within 150 seconds"
          docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml ps
          docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml logs --tail=50
          exit 1
        fi
        docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml ps

    - name: Test service endpoints
      if: steps.check.outputs.build == 'true'
      run: |
        # Use localhost since port 8080 is exposed directly in docker-compose.ci.yml
        # (Avoids issues with multiple networks causing concatenated IPs)

        test_endpoint() {
          local url=$1
          local name=$2
          local max_retries=5
          local retry_delay=2

          echo "Testing $name..."
          for i in $(seq 1 $max_retries); do
            if curl -f -s -o /dev/null -w "%{http_code}" "$url" | grep -q "200"; then
              echo "‚úì $name is responding correctly"
              return 0
            else
              echo "  Attempt $i/$max_retries failed for $name"
              if [ $i -lt $max_retries ]; then
                sleep $retry_delay
              fi
            fi
          done
          echo "‚ùå $name failed after $max_retries attempts"
          curl -v "$url" || true
          return 1
        }

        echo "=== Testing via Caddy (main entry point) ==="
        test_endpoint "http://localhost:8080/health" "Health check" || exit 1
        test_endpoint "http://localhost:8080/api/config" "FastAPI config" || exit 1

        echo "‚úÖ All integration tests passed!"

    - name: Verify non-root user and write permissions
      if: steps.check.outputs.build == 'true'
      run: |
        # Use docker compose exec to run commands in the service container
        # (Avoids issues with container name lookup)
        COMPOSE_CMD="docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml exec -T kindred"

        CONTAINER_USER=$($COMPOSE_CMD id -u)
        if [ "$CONTAINER_USER" = "0" ]; then
          echo "‚ùå Container is running as root!"
          exit 1
        fi
        echo "‚úì Container running as UID: $CONTAINER_USER"

        $COMPOSE_CMD sh -c "touch /pb_data/write_test && rm /pb_data/write_test"
        echo "‚úì Database directory is writable by non-root user"

        # Verify entrypoint is world-readable (required for shell scripts)
        # This catches local builds with restrictive umask (600 ‚Üí chmod +x ‚Üí 711)
        ENTRYPOINT_PERMS=$($COMPOSE_CMD stat -c "%a" /entrypoint.sh)
        if [ "$ENTRYPOINT_PERMS" != "755" ]; then
          echo "‚ùå Entrypoint has wrong permissions: $ENTRYPOINT_PERMS (expected 755)"
          echo "   This usually means the Dockerfile uses 'chmod +x' instead of 'chmod 755'"
          exit 1
        fi
        echo "‚úì Entrypoint has correct permissions (755)"

    - name: Show logs on test failure
      if: failure() && steps.check.outputs.build == 'true'
      run: |
        echo "=== Docker Compose Status ==="
        docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml ps
        echo ""
        echo "=== Kindred Logs ==="
        docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml logs kindred

    - name: Stop test stack
      if: always() && steps.check.outputs.build == 'true'
      run: |
        docker compose --env-file .env.ci -f docker-compose.yml -f docker-compose.ci.yml down -v || true
        # Use sudo to clean up files created by container (runs as UID 1000, different from runner)
        sudo rm -rf /tmp/kindred-ci-${{ github.run_id }}

    # === Security Scan (run before push) ===
    - name: Run Trivy vulnerability scanner
      if: steps.check.outputs.build == 'true'
      uses: aquasecurity/trivy-action@0.33.1
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.USERNAME }}/${{ matrix.image }}:test
        version: 'v0.68.2'
        format: 'sarif'
        output: 'trivy-results-${{ matrix.image }}.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '0'

    - name: Upload Trivy scan results to GitHub Security
      if: steps.check.outputs.build == 'true'
      continue-on-error: true
      uses: github/codeql-action/upload-sarif@v4
      with:
        sarif_file: 'trivy-results-${{ matrix.image }}.sarif'

    # === Push to Registry (only if tests pass and not dry-run/PR) ===
    # Tag and push the already-built :test image instead of rebuilding (~3-5 min savings)
    - name: Push Docker image
      if: |
        steps.check.outputs.build == 'true' &&
        github.event_name != 'pull_request' &&
        github.event.inputs.dry_run != 'true'
      run: |
        TEST_IMAGE="${{ env.REGISTRY }}/${{ env.USERNAME }}/${{ matrix.image }}:test"

        # Tags are comma-separated, iterate and push each
        IFS=',' read -ra TAG_ARRAY <<< "${{ steps.tags.outputs.tags }}"
        for tag in "${TAG_ARRAY[@]}"; do
          echo "Tagging and pushing: $tag"
          docker tag "$TEST_IMAGE" "$tag"
          docker push "$tag"
        done

        echo "‚úÖ All tags pushed successfully"

    - name: Skip push (dry-run or PR)
      if: |
        steps.check.outputs.build == 'true' &&
        (github.event_name == 'pull_request' || github.event.inputs.dry_run == 'true')
      run: |
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          echo "üîç PR validation mode - image built and tested but NOT pushed"
        else
          echo "üîç Dry-run mode - image built and tested but NOT pushed"
        fi
        echo "   To push, trigger manually without dry_run or create a release tag"

  # Summary job
  summary:
    name: Build Summary
    needs: [build-test-push]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Check build status
      run: |
        if [ "${{ needs.build-test-push.result }}" != "success" ] && [ "${{ needs.build-test-push.result }}" != "skipped" ]; then
          echo "‚ùå Build, test, or push failed!"
          exit 1
        fi

        if [ "${{ needs.build-test-push.result }}" == "skipped" ]; then
          echo "‚ÑπÔ∏è  Docker build skipped (no relevant file changes)"
        elif [ "${{ github.event_name }}" == "pull_request" ]; then
          echo "‚úÖ CD validation passed (PR mode - no push)"
          echo ""
          echo "This PR's CD changes have been validated:"
          echo "- Docker image built successfully"
          echo "- Integration tests passed"
          echo "- Security scan completed"
          echo ""
          echo "Image will be pushed when this PR merges and a release is created."
        elif [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
          echo "‚úÖ CD dry-run passed (no push)"
          echo ""
          echo "Validated:"
          echo "- Docker image built successfully"
          echo "- Integration tests passed"
          echo "- Security scan completed"
          echo ""
          echo "To push, run again without dry_run or create a release tag."
        else
          echo "‚úÖ All CD checks passed successfully!"
          echo ""
          echo "Image pushed:"
          echo "- ghcr.io/${{ env.USERNAME }}/kindred (Caddy + PocketBase + FastAPI)"
        fi

  # Auto-generate release notes from conventional commits
  create-release:
    name: Create GitHub Release
    needs: [build-test-push]
    runs-on: ubuntu-latest
    # Only run on tag pushes, not release events (release already exists) or manual triggers
    if: success() && startsWith(github.ref, 'refs/tags/v') && github.event_name == 'push'
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0  # Need full history for git-cliff

    - name: Install git-cliff
      uses: kenji-miyake/setup-git-cliff@v2

    - name: Generate changelog
      id: changelog
      run: |
        # Get the current tag
        CURRENT_TAG=${GITHUB_REF#refs/tags/}
        echo "Current tag: $CURRENT_TAG"

        # Get the previous tag
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        echo "Previous tag: $PREV_TAG"

        if [ -n "$PREV_TAG" ]; then
          echo "Generating changelog from $PREV_TAG to $CURRENT_TAG"
          git cliff $PREV_TAG..$CURRENT_TAG --strip header > RELEASE_NOTES.md
        else
          echo "No previous tag found, generating changelog for all commits"
          git cliff --latest --strip header > RELEASE_NOTES.md
        fi

        echo "=== Generated Release Notes ==="
        cat RELEASE_NOTES.md

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        body_path: RELEASE_NOTES.md
        generate_release_notes: false
